/*
 * generated by Xtext 2.27.0
 */
package org.gemoc.ql.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.gemoc.ql.model.ql.BasicBinaryExpression;
import org.gemoc.ql.model.ql.BasicUnaryExpression;
import org.gemoc.ql.model.ql.BooleanValue;
import org.gemoc.ql.model.ql.BooleanValueType;
import org.gemoc.ql.model.ql.ConstantCall;
import org.gemoc.ql.model.ql.DateValue;
import org.gemoc.ql.model.ql.DateValueType;
import org.gemoc.ql.model.ql.DecimalValue;
import org.gemoc.ql.model.ql.DecimalValueType;
import org.gemoc.ql.model.ql.DefinitionGroup;
import org.gemoc.ql.model.ql.EnumerationCall;
import org.gemoc.ql.model.ql.EnumerationLiteral;
import org.gemoc.ql.model.ql.EnumerationValueType;
import org.gemoc.ql.model.ql.Form;
import org.gemoc.ql.model.ql.IfExpression;
import org.gemoc.ql.model.ql.IntegerValue;
import org.gemoc.ql.model.ql.IntegerValueType;
import org.gemoc.ql.model.ql.QLModel;
import org.gemoc.ql.model.ql.QlPackage;
import org.gemoc.ql.model.ql.Question;
import org.gemoc.ql.model.ql.QuestionCall;
import org.gemoc.ql.model.ql.QuestionDefinition;
import org.gemoc.ql.model.ql.QuestionGroup;
import org.gemoc.ql.model.ql.StringValue;
import org.gemoc.ql.model.ql.StringValueType;
import org.gemoc.ql.model.ql.ValueType;
import org.gemoc.ql.services.QLGrammarAccess;

@SuppressWarnings("all")
public class QLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private QLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == QlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case QlPackage.BASIC_BINARY_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getUnaryOrPrimaryExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getEqualExpressionRule()
						|| action == grammarAccess.getEqualExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getComparisionExpressionRule()
						|| action == grammarAccess.getComparisionExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getAdditionExpressionRule()
						|| action == grammarAccess.getAdditionExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getMultiplicationExpressionRule()
						|| action == grammarAccess.getMultiplicationExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()) {
					sequence_AdditionExpression_AndExpression_ComparisionExpression_EqualExpression_MultiplicationExpression_OrExpression(context, (BasicBinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBasicBinaryExpressionRule()) {
					sequence_BasicBinaryExpression(context, (BasicBinaryExpression) semanticObject); 
					return; 
				}
				else break;
			case QlPackage.BASIC_UNARY_EXPRESSION:
				if (rule == grammarAccess.getBasicUnaryExpressionRule()) {
					sequence_BasicUnaryExpression(context, (BasicUnaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getUnaryOrPrimaryExpressionRule()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getEqualExpressionRule()
						|| action == grammarAccess.getEqualExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getComparisionExpressionRule()
						|| action == grammarAccess.getComparisionExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getAdditionExpressionRule()
						|| action == grammarAccess.getAdditionExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getMultiplicationExpressionRule()
						|| action == grammarAccess.getMultiplicationExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()) {
					sequence_UnaryExpression(context, (BasicUnaryExpression) semanticObject); 
					return; 
				}
				else break;
			case QlPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case QlPackage.BOOLEAN_VALUE_TYPE:
				sequence_BooleanValueType(context, (BooleanValueType) semanticObject); 
				return; 
			case QlPackage.CONSTANT_CALL:
				sequence_ConstantCall(context, (ConstantCall) semanticObject); 
				return; 
			case QlPackage.DATE_VALUE:
				sequence_DateValue(context, (DateValue) semanticObject); 
				return; 
			case QlPackage.DATE_VALUE_TYPE:
				sequence_DateValueType(context, (DateValueType) semanticObject); 
				return; 
			case QlPackage.DECIMAL_VALUE:
				sequence_DecimalValue(context, (DecimalValue) semanticObject); 
				return; 
			case QlPackage.DECIMAL_VALUE_TYPE:
				sequence_DecimalValueType(context, (DecimalValueType) semanticObject); 
				return; 
			case QlPackage.DEFINITION_GROUP:
				sequence_DefinitionGroup(context, (DefinitionGroup) semanticObject); 
				return; 
			case QlPackage.ENUMERATION_CALL:
				sequence_EnumerationCall(context, (EnumerationCall) semanticObject); 
				return; 
			case QlPackage.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case QlPackage.ENUMERATION_VALUE_TYPE:
				sequence_EnumerationValueType(context, (EnumerationValueType) semanticObject); 
				return; 
			case QlPackage.FORM:
				sequence_Form(context, (Form) semanticObject); 
				return; 
			case QlPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case QlPackage.INTEGER_VALUE:
				sequence_IntegerValue(context, (IntegerValue) semanticObject); 
				return; 
			case QlPackage.INTEGER_VALUE_TYPE:
				sequence_IntegerValueType(context, (IntegerValueType) semanticObject); 
				return; 
			case QlPackage.QL_MODEL:
				sequence_QLModel(context, (QLModel) semanticObject); 
				return; 
			case QlPackage.QUESTION:
				sequence_Question(context, (Question) semanticObject); 
				return; 
			case QlPackage.QUESTION_CALL:
				sequence_QuestionCall(context, (QuestionCall) semanticObject); 
				return; 
			case QlPackage.QUESTION_DEFINITION:
				sequence_QuestionDefinition(context, (QuestionDefinition) semanticObject); 
				return; 
			case QlPackage.QUESTION_GROUP:
				sequence_QuestionGroup(context, (QuestionGroup) semanticObject); 
				return; 
			case QlPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case QlPackage.STRING_VALUE_TYPE:
				sequence_StringValueType(context, (StringValueType) semanticObject); 
				return; 
			case QlPackage.VALUE_TYPE:
				sequence_ValueType_Impl(context, (ValueType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BasicBinaryExpression
	 *     UnaryOrPrimaryExpression returns BasicBinaryExpression
	 *     PrimaryExpression returns BasicBinaryExpression
	 *     OrExpression returns BasicBinaryExpression
	 *     OrExpression.BasicBinaryExpression_1_0 returns BasicBinaryExpression
	 *     AndExpression returns BasicBinaryExpression
	 *     AndExpression.BasicBinaryExpression_1_0 returns BasicBinaryExpression
	 *     EqualExpression returns BasicBinaryExpression
	 *     EqualExpression.BasicBinaryExpression_1_0 returns BasicBinaryExpression
	 *     ComparisionExpression returns BasicBinaryExpression
	 *     ComparisionExpression.BasicBinaryExpression_1_0 returns BasicBinaryExpression
	 *     AdditionExpression returns BasicBinaryExpression
	 *     AdditionExpression.BasicBinaryExpression_1_0 returns BasicBinaryExpression
	 *     MultiplicationExpression returns BasicBinaryExpression
	 *     MultiplicationExpression.BasicBinaryExpression_1_0 returns BasicBinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (lhsOperand=OrExpression_BasicBinaryExpression_1_0 operator=OrOperatorKind rhsOperand=AndExpression) | 
	 *         (lhsOperand=AndExpression_BasicBinaryExpression_1_0 operator=AndOperatorKind rhsOperand=EqualExpression) | 
	 *         (lhsOperand=EqualExpression_BasicBinaryExpression_1_0 operator=EqualOperatorKind rhsOperand=ComparisionExpression) | 
	 *         (lhsOperand=ComparisionExpression_BasicBinaryExpression_1_0 operator=ComparisionOperatorKind rhsOperand=AdditionExpression) | 
	 *         (lhsOperand=AdditionExpression_BasicBinaryExpression_1_0 operator=AdditionOperatorKind rhsOperand=MultiplicationExpression) | 
	 *         (lhsOperand=MultiplicationExpression_BasicBinaryExpression_1_0 operator=MultiplicationOperatorKind rhsOperand=UnaryOrPrimaryExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_AdditionExpression_AndExpression_ComparisionExpression_EqualExpression_MultiplicationExpression_OrExpression(ISerializationContext context, BasicBinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BasicBinaryExpression returns BasicBinaryExpression
	 *
	 * Constraint:
	 *     (operator=BinaryOperatorKind resultType=[ValueType|EString]? lhsOperand=Expression rhsOperand=Expression)
	 * </pre>
	 */
	protected void sequence_BasicBinaryExpression(ISerializationContext context, BasicBinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BasicUnaryExpression returns BasicUnaryExpression
	 *
	 * Constraint:
	 *     (operator=UnaryOperatorKind? resultType=[ValueType|QualifiedName]? operand=Expression)
	 * </pre>
	 */
	protected void sequence_BasicUnaryExpression(ISerializationContext context, BasicUnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns BooleanValueType
	 *     BooleanValueType returns BooleanValueType
	 *
	 * Constraint:
	 *     (name=ID unit=EString?)
	 * </pre>
	 */
	protected void sequence_BooleanValueType(ISerializationContext context, BooleanValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns BooleanValue
	 *     BooleanValue returns BooleanValue
	 *
	 * Constraint:
	 *     booleanValue=EBoolean
	 * </pre>
	 */
	protected void sequence_BooleanValue(ISerializationContext context, BooleanValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.BOOLEAN_VALUE__BOOLEAN_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.BOOLEAN_VALUE__BOOLEAN_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanValueAccess().getBooleanValueEBooleanParserRuleCall_1_0(), semanticObject.isBooleanValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ConstantCall
	 *     UnaryOrPrimaryExpression returns ConstantCall
	 *     PrimaryExpression returns ConstantCall
	 *     OrExpression returns ConstantCall
	 *     OrExpression.BasicBinaryExpression_1_0 returns ConstantCall
	 *     AndExpression returns ConstantCall
	 *     AndExpression.BasicBinaryExpression_1_0 returns ConstantCall
	 *     EqualExpression returns ConstantCall
	 *     EqualExpression.BasicBinaryExpression_1_0 returns ConstantCall
	 *     ComparisionExpression returns ConstantCall
	 *     ComparisionExpression.BasicBinaryExpression_1_0 returns ConstantCall
	 *     AdditionExpression returns ConstantCall
	 *     AdditionExpression.BasicBinaryExpression_1_0 returns ConstantCall
	 *     MultiplicationExpression returns ConstantCall
	 *     MultiplicationExpression.BasicBinaryExpression_1_0 returns ConstantCall
	 *     Call returns ConstantCall
	 *     ConstantCall returns ConstantCall
	 *
	 * Constraint:
	 *     (value=StringValue | value=IntegerValue | value=BooleanValue | value=DecimalValue)
	 * </pre>
	 */
	protected void sequence_ConstantCall(ISerializationContext context, ConstantCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns DateValueType
	 *     DateValueType returns DateValueType
	 *
	 * Constraint:
	 *     (name=ID unit=EString?)
	 * </pre>
	 */
	protected void sequence_DateValueType(ISerializationContext context, DateValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns DateValue
	 *     DateValue returns DateValue
	 *
	 * Constraint:
	 *     dateValue=EDate?
	 * </pre>
	 */
	protected void sequence_DateValue(ISerializationContext context, DateValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns DecimalValueType
	 *     DecimalValueType returns DecimalValueType
	 *
	 * Constraint:
	 *     (name=ID unit=EString?)
	 * </pre>
	 */
	protected void sequence_DecimalValueType(ISerializationContext context, DecimalValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns DecimalValue
	 *     DecimalValue returns DecimalValue
	 *
	 * Constraint:
	 *     decimalValue=EFloat
	 * </pre>
	 */
	protected void sequence_DecimalValue(ISerializationContext context, DecimalValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.DECIMAL_VALUE__DECIMAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.DECIMAL_VALUE__DECIMAL_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalValueAccess().getDecimalValueEFloatParserRuleCall_1_0(), semanticObject.getDecimalValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefinitionGroup returns DefinitionGroup
	 *
	 * Constraint:
	 *     (questionDefinitions+=QuestionDefinition | dataTypes+=ValueType)*
	 * </pre>
	 */
	protected void sequence_DefinitionGroup(ISerializationContext context, DefinitionGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns EnumerationCall
	 *     UnaryOrPrimaryExpression returns EnumerationCall
	 *     PrimaryExpression returns EnumerationCall
	 *     OrExpression returns EnumerationCall
	 *     OrExpression.BasicBinaryExpression_1_0 returns EnumerationCall
	 *     AndExpression returns EnumerationCall
	 *     AndExpression.BasicBinaryExpression_1_0 returns EnumerationCall
	 *     EqualExpression returns EnumerationCall
	 *     EqualExpression.BasicBinaryExpression_1_0 returns EnumerationCall
	 *     ComparisionExpression returns EnumerationCall
	 *     ComparisionExpression.BasicBinaryExpression_1_0 returns EnumerationCall
	 *     AdditionExpression returns EnumerationCall
	 *     AdditionExpression.BasicBinaryExpression_1_0 returns EnumerationCall
	 *     MultiplicationExpression returns EnumerationCall
	 *     MultiplicationExpression.BasicBinaryExpression_1_0 returns EnumerationCall
	 *     Call returns EnumerationCall
	 *     EnumerationCall returns EnumerationCall
	 *
	 * Constraint:
	 *     enumerationLiteral=[EnumerationLiteral|QualifiedName]
	 * </pre>
	 */
	protected void sequence_EnumerationCall(ISerializationContext context, EnumerationCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.ENUMERATION_CALL__ENUMERATION_LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.ENUMERATION_CALL__ENUMERATION_LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationCallAccess().getEnumerationLiteralEnumerationLiteralQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(QlPackage.Literals.ENUMERATION_CALL__ENUMERATION_LITERAL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumerationLiteral returns EnumerationLiteral
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_EnumerationLiteral(ISerializationContext context, EnumerationLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.ENUMERATION_LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.ENUMERATION_LITERAL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationLiteralAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns EnumerationValueType
	 *     EnumerationValueType returns EnumerationValueType
	 *
	 * Constraint:
	 *     (name=ID unit=EString? (enumerationLiterals+=EnumerationLiteral enumerationLiterals+=EnumerationLiteral*)?)
	 * </pre>
	 */
	protected void sequence_EnumerationValueType(ISerializationContext context, EnumerationValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Form returns Form
	 *
	 * Constraint:
	 *     (name=ID questionGroup=QuestionGroup)
	 * </pre>
	 */
	protected void sequence_Form(ISerializationContext context, Form semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.FORM__QUESTION_GROUP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.FORM__QUESTION_GROUP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFormAccess().getQuestionGroupQuestionGroupParserRuleCall_2_0(), semanticObject.getQuestionGroup());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns IfExpression
	 *     UnaryOrPrimaryExpression returns IfExpression
	 *     PrimaryExpression returns IfExpression
	 *     IfExpression returns IfExpression
	 *     OrExpression returns IfExpression
	 *     OrExpression.BasicBinaryExpression_1_0 returns IfExpression
	 *     AndExpression returns IfExpression
	 *     AndExpression.BasicBinaryExpression_1_0 returns IfExpression
	 *     EqualExpression returns IfExpression
	 *     EqualExpression.BasicBinaryExpression_1_0 returns IfExpression
	 *     ComparisionExpression returns IfExpression
	 *     ComparisionExpression.BasicBinaryExpression_1_0 returns IfExpression
	 *     AdditionExpression returns IfExpression
	 *     AdditionExpression.BasicBinaryExpression_1_0 returns IfExpression
	 *     MultiplicationExpression returns IfExpression
	 *     MultiplicationExpression.BasicBinaryExpression_1_0 returns IfExpression
	 *
	 * Constraint:
	 *     (condition=Expression thenExpression=Expression elseExpression=Expression?)
	 * </pre>
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns IntegerValueType
	 *     IntegerValueType returns IntegerValueType
	 *
	 * Constraint:
	 *     (name=ID unit=EString? min=EInt? max=EInt?)
	 * </pre>
	 */
	protected void sequence_IntegerValueType(ISerializationContext context, IntegerValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns IntegerValue
	 *     IntegerValue returns IntegerValue
	 *
	 * Constraint:
	 *     intValue=EInt
	 * </pre>
	 */
	protected void sequence_IntegerValue(ISerializationContext context, IntegerValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.INTEGER_VALUE__INT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.INTEGER_VALUE__INT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerValueAccess().getIntValueEIntParserRuleCall_1_0(), semanticObject.getIntValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QLModel returns QLModel
	 *
	 * Constraint:
	 *     (canSubmit?='canSubmit'? submitDate=EDate? (definitionGroup+=DefinitionGroup | forms+=Form)*)
	 * </pre>
	 */
	protected void sequence_QLModel(ISerializationContext context, QLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns QuestionCall
	 *     UnaryOrPrimaryExpression returns QuestionCall
	 *     PrimaryExpression returns QuestionCall
	 *     OrExpression returns QuestionCall
	 *     OrExpression.BasicBinaryExpression_1_0 returns QuestionCall
	 *     AndExpression returns QuestionCall
	 *     AndExpression.BasicBinaryExpression_1_0 returns QuestionCall
	 *     EqualExpression returns QuestionCall
	 *     EqualExpression.BasicBinaryExpression_1_0 returns QuestionCall
	 *     ComparisionExpression returns QuestionCall
	 *     ComparisionExpression.BasicBinaryExpression_1_0 returns QuestionCall
	 *     AdditionExpression returns QuestionCall
	 *     AdditionExpression.BasicBinaryExpression_1_0 returns QuestionCall
	 *     MultiplicationExpression returns QuestionCall
	 *     MultiplicationExpression.BasicBinaryExpression_1_0 returns QuestionCall
	 *     Call returns QuestionCall
	 *     QuestionCall returns QuestionCall
	 *
	 * Constraint:
	 *     question=[QuestionDefinition|QualifiedName]
	 * </pre>
	 */
	protected void sequence_QuestionCall(ISerializationContext context, QuestionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.QUESTION_CALL__QUESTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.QUESTION_CALL__QUESTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQuestionCallAccess().getQuestionQuestionDefinitionQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(QlPackage.Literals.QUESTION_CALL__QUESTION, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QuestionDefinition returns QuestionDefinition
	 *
	 * Constraint:
	 *     (
	 *         isMandatory?='mandatory'? 
	 *         name=EString 
	 *         isDisplayed?='isDisplayed'? 
	 *         currentValue=Value? 
	 *         label=EString 
	 *         dataType=[ValueType|EString] 
	 *         computedExpression=Expression?
	 *     )
	 * </pre>
	 */
	protected void sequence_QuestionDefinition(ISerializationContext context, QuestionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QuestionGroup returns QuestionGroup
	 *
	 * Constraint:
	 *     (guard=Expression? (questionGroups+=QuestionGroup | questions+=Question)*)
	 * </pre>
	 */
	protected void sequence_QuestionGroup(ISerializationContext context, QuestionGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Question returns Question
	 *
	 * Constraint:
	 *     questionDefinition=[QuestionDefinition|QualifiedName]
	 * </pre>
	 */
	protected void sequence_Question(ISerializationContext context, Question semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.QUESTION__QUESTION_DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.QUESTION__QUESTION_DEFINITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQuestionAccess().getQuestionDefinitionQuestionDefinitionQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(QlPackage.Literals.QUESTION__QUESTION_DEFINITION, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns StringValueType
	 *     StringValueType returns StringValueType
	 *
	 * Constraint:
	 *     (name=ID unit=EString?)
	 * </pre>
	 */
	protected void sequence_StringValueType(ISerializationContext context, StringValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     stringValue=STRING
	 * </pre>
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.STRING_VALUE__STRING_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.STRING_VALUE__STRING_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getStringValueSTRINGTerminalRuleCall_1_0(), semanticObject.getStringValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BasicUnaryExpression
	 *     UnaryOrPrimaryExpression returns BasicUnaryExpression
	 *     UnaryExpression returns BasicUnaryExpression
	 *     PrimaryExpression returns BasicUnaryExpression
	 *     OrExpression returns BasicUnaryExpression
	 *     OrExpression.BasicBinaryExpression_1_0 returns BasicUnaryExpression
	 *     AndExpression returns BasicUnaryExpression
	 *     AndExpression.BasicBinaryExpression_1_0 returns BasicUnaryExpression
	 *     EqualExpression returns BasicUnaryExpression
	 *     EqualExpression.BasicBinaryExpression_1_0 returns BasicUnaryExpression
	 *     ComparisionExpression returns BasicUnaryExpression
	 *     ComparisionExpression.BasicBinaryExpression_1_0 returns BasicUnaryExpression
	 *     AdditionExpression returns BasicUnaryExpression
	 *     AdditionExpression.BasicBinaryExpression_1_0 returns BasicUnaryExpression
	 *     MultiplicationExpression returns BasicUnaryExpression
	 *     MultiplicationExpression.BasicBinaryExpression_1_0 returns BasicUnaryExpression
	 *
	 * Constraint:
	 *     (operator=UnaryOperatorKind operand=UnaryOrPrimaryExpression)
	 * </pre>
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, BasicUnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.BASIC_UNARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.BASIC_UNARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOperatorUnaryOperatorKindEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOperandUnaryOrPrimaryExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns ValueType
	 *     ValueType_Impl returns ValueType
	 *
	 * Constraint:
	 *     (name=ID unit=EString?)
	 * </pre>
	 */
	protected void sequence_ValueType_Impl(ISerializationContext context, ValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
