/*
 * generated by Xtext 2.35.0
 */
package org.gemoc.ql.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.gemoc.ql.model.ql.BasicBinaryExpression;
import org.gemoc.ql.model.ql.BasicUnaryExpression;
import org.gemoc.ql.model.ql.BooleanValue;
import org.gemoc.ql.model.ql.BooleanValueType;
import org.gemoc.ql.model.ql.ConstantCall;
import org.gemoc.ql.model.ql.DateValue;
import org.gemoc.ql.model.ql.DateValueType;
import org.gemoc.ql.model.ql.DecimalValue;
import org.gemoc.ql.model.ql.DecimalValueType;
import org.gemoc.ql.model.ql.DefinitionGroup;
import org.gemoc.ql.model.ql.EnumerationLiteral;
import org.gemoc.ql.model.ql.EnumerationValueType;
import org.gemoc.ql.model.ql.Form;
import org.gemoc.ql.model.ql.IntegerValue;
import org.gemoc.ql.model.ql.IntegerValueType;
import org.gemoc.ql.model.ql.QLModel;
import org.gemoc.ql.model.ql.QlPackage;
import org.gemoc.ql.model.ql.Question;
import org.gemoc.ql.model.ql.QuestionCall;
import org.gemoc.ql.model.ql.QuestionDefinition;
import org.gemoc.ql.model.ql.QuestionGroup;
import org.gemoc.ql.model.ql.StringValue;
import org.gemoc.ql.model.ql.StringValueType;
import org.gemoc.ql.model.ql.ValueType;
import org.gemoc.ql.services.QLGrammarAccess;

@SuppressWarnings("all")
public class QLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private QLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == QlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case QlPackage.BASIC_BINARY_EXPRESSION:
				sequence_BasicBinaryExpression(context, (BasicBinaryExpression) semanticObject); 
				return; 
			case QlPackage.BASIC_UNARY_EXPRESSION:
				sequence_BasicUnaryExpression(context, (BasicUnaryExpression) semanticObject); 
				return; 
			case QlPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case QlPackage.BOOLEAN_VALUE_TYPE:
				sequence_BooleanValueType(context, (BooleanValueType) semanticObject); 
				return; 
			case QlPackage.CONSTANT_CALL:
				sequence_ConstantCall(context, (ConstantCall) semanticObject); 
				return; 
			case QlPackage.DATE_VALUE:
				sequence_DateValue(context, (DateValue) semanticObject); 
				return; 
			case QlPackage.DATE_VALUE_TYPE:
				sequence_DateValueType(context, (DateValueType) semanticObject); 
				return; 
			case QlPackage.DECIMAL_VALUE:
				sequence_DecimalValue(context, (DecimalValue) semanticObject); 
				return; 
			case QlPackage.DECIMAL_VALUE_TYPE:
				sequence_DecimalValueType(context, (DecimalValueType) semanticObject); 
				return; 
			case QlPackage.DEFINITION_GROUP:
				sequence_DefinitionGroup(context, (DefinitionGroup) semanticObject); 
				return; 
			case QlPackage.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case QlPackage.ENUMERATION_VALUE_TYPE:
				sequence_EnumerationValueType(context, (EnumerationValueType) semanticObject); 
				return; 
			case QlPackage.FORM:
				sequence_Form(context, (Form) semanticObject); 
				return; 
			case QlPackage.INTEGER_VALUE:
				sequence_IntegerValue(context, (IntegerValue) semanticObject); 
				return; 
			case QlPackage.INTEGER_VALUE_TYPE:
				sequence_IntegerValueType(context, (IntegerValueType) semanticObject); 
				return; 
			case QlPackage.QL_MODEL:
				sequence_QLModel(context, (QLModel) semanticObject); 
				return; 
			case QlPackage.QUESTION:
				sequence_Question(context, (Question) semanticObject); 
				return; 
			case QlPackage.QUESTION_CALL:
				sequence_QuestionCall(context, (QuestionCall) semanticObject); 
				return; 
			case QlPackage.QUESTION_DEFINITION:
				sequence_QuestionDefinition(context, (QuestionDefinition) semanticObject); 
				return; 
			case QlPackage.QUESTION_GROUP:
				sequence_QuestionGroup(context, (QuestionGroup) semanticObject); 
				return; 
			case QlPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case QlPackage.STRING_VALUE_TYPE:
				sequence_StringValueType(context, (StringValueType) semanticObject); 
				return; 
			case QlPackage.VALUE_TYPE:
				sequence_ValueType_Impl(context, (ValueType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BasicBinaryExpression
	 *     BasicBinaryExpression returns BasicBinaryExpression
	 *
	 * Constraint:
	 *     (operator=BinaryOperatorKind resultType=[ValueType|EString]? lhsOperand=Expression rhsOperand=Expression)
	 * </pre>
	 */
	protected void sequence_BasicBinaryExpression(ISerializationContext context, BasicBinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BasicUnaryExpression
	 *     BasicUnaryExpression returns BasicUnaryExpression
	 *
	 * Constraint:
	 *     (operator=UnaryOperatorKind? resultType=[ValueType|EString]? operand=Expression)
	 * </pre>
	 */
	protected void sequence_BasicUnaryExpression(ISerializationContext context, BasicUnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns BooleanValueType
	 *     BooleanValueType returns BooleanValueType
	 *
	 * Constraint:
	 *     (name=EString unit=EString?)
	 * </pre>
	 */
	protected void sequence_BooleanValueType(ISerializationContext context, BooleanValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns BooleanValue
	 *     BooleanValue returns BooleanValue
	 *
	 * Constraint:
	 *     booleanValue?='booleanValue'?
	 * </pre>
	 */
	protected void sequence_BooleanValue(ISerializationContext context, BooleanValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ConstantCall
	 *     ConstantCall returns ConstantCall
	 *
	 * Constraint:
	 *     (resultType=[ValueType|EString]? value=Value?)
	 * </pre>
	 */
	protected void sequence_ConstantCall(ISerializationContext context, ConstantCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns DateValueType
	 *     DateValueType returns DateValueType
	 *
	 * Constraint:
	 *     (name=EString unit=EString?)
	 * </pre>
	 */
	protected void sequence_DateValueType(ISerializationContext context, DateValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns DateValue
	 *     DateValue returns DateValue
	 *
	 * Constraint:
	 *     dateValue=EDate?
	 * </pre>
	 */
	protected void sequence_DateValue(ISerializationContext context, DateValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns DecimalValueType
	 *     DecimalValueType returns DecimalValueType
	 *
	 * Constraint:
	 *     (name=EString unit=EString?)
	 * </pre>
	 */
	protected void sequence_DecimalValueType(ISerializationContext context, DecimalValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns DecimalValue
	 *     DecimalValue returns DecimalValue
	 *
	 * Constraint:
	 *     decimalValue=EFloat?
	 * </pre>
	 */
	protected void sequence_DecimalValue(ISerializationContext context, DecimalValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefinitionGroup returns DefinitionGroup
	 *
	 * Constraint:
	 *     (questionDefinitions+=QuestionDefinition | dataTypes+=ValueType)*
	 * </pre>
	 */
	protected void sequence_DefinitionGroup(ISerializationContext context, DefinitionGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumerationLiteral returns EnumerationLiteral
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_EnumerationLiteral(ISerializationContext context, EnumerationLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationLiteralAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns EnumerationValueType
	 *     EnumerationValueType returns EnumerationValueType
	 *
	 * Constraint:
	 *     (name=EString unit=EString? (enumerationLiterals+=EnumerationLiteral enumerationLiterals+=EnumerationLiteral*)?)
	 * </pre>
	 */
	protected void sequence_EnumerationValueType(ISerializationContext context, EnumerationValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Form returns Form
	 *
	 * Constraint:
	 *     (name=EString questionGroup=QuestionGroup)
	 * </pre>
	 */
	protected void sequence_Form(ISerializationContext context, Form semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.FORM__QUESTION_GROUP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.FORM__QUESTION_GROUP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFormAccess().getQuestionGroupQuestionGroupParserRuleCall_4_0(), semanticObject.getQuestionGroup());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns IntegerValueType
	 *     IntegerValueType returns IntegerValueType
	 *
	 * Constraint:
	 *     (name=EString unit=EString? min=EInt? max=EInt?)
	 * </pre>
	 */
	protected void sequence_IntegerValueType(ISerializationContext context, IntegerValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns IntegerValue
	 *     IntegerValue returns IntegerValue
	 *
	 * Constraint:
	 *     intValue=EInt?
	 * </pre>
	 */
	protected void sequence_IntegerValue(ISerializationContext context, IntegerValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QLModel returns QLModel
	 *
	 * Constraint:
	 *     (canSubmit?='canSubmit'? submitDate=EDate? (forms+=Form forms+=Form*)? (definitionGroup+=DefinitionGroup definitionGroup+=DefinitionGroup*)?)
	 * </pre>
	 */
	protected void sequence_QLModel(ISerializationContext context, QLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns QuestionCall
	 *     QuestionCall returns QuestionCall
	 *
	 * Constraint:
	 *     (resultType=[ValueType|EString]? question=[QuestionDefinition|EString])
	 * </pre>
	 */
	protected void sequence_QuestionCall(ISerializationContext context, QuestionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QuestionDefinition returns QuestionDefinition
	 *
	 * Constraint:
	 *     (
	 *         isDisplayed?='isDisplayed'? 
	 *         isMandatory?='isMandatory'? 
	 *         name=EString 
	 *         label=EString? 
	 *         dataType=[ValueType|EString] 
	 *         computedExpression=Expression? 
	 *         currentValue=Value?
	 *     )
	 * </pre>
	 */
	protected void sequence_QuestionDefinition(ISerializationContext context, QuestionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QuestionGroup returns QuestionGroup
	 *
	 * Constraint:
	 *     (guard=Expression? (questionGroups+=QuestionGroup questionGroups+=QuestionGroup*)? (questions+=Question questions+=Question*)?)
	 * </pre>
	 */
	protected void sequence_QuestionGroup(ISerializationContext context, QuestionGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Question returns Question
	 *
	 * Constraint:
	 *     questionDefinition=[QuestionDefinition|EString]
	 * </pre>
	 */
	protected void sequence_Question(ISerializationContext context, Question semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlPackage.Literals.QUESTION__QUESTION_DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlPackage.Literals.QUESTION__QUESTION_DEFINITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQuestionAccess().getQuestionDefinitionQuestionDefinitionEStringParserRuleCall_3_0_1(), semanticObject.eGet(QlPackage.Literals.QUESTION__QUESTION_DEFINITION, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns StringValueType
	 *     StringValueType returns StringValueType
	 *
	 * Constraint:
	 *     (name=EString unit=EString?)
	 * </pre>
	 */
	protected void sequence_StringValueType(ISerializationContext context, StringValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     stringValue=EString?
	 * </pre>
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueType returns ValueType
	 *     ValueType_Impl returns ValueType
	 *
	 * Constraint:
	 *     (name=EString unit=EString?)
	 * </pre>
	 */
	protected void sequence_ValueType_Impl(ISerializationContext context, ValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
