/**
 * generated by Xtext 2.31.0
 */
package org.gemoc.ql.validation;

import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.gemoc.ql.k3ql.k3dsa.ql.ExpressionAspect;
import org.gemoc.ql.k3ql.k3dsa.ql.ValueTypeAspect;
import org.gemoc.ql.model.ql.BasicBinaryExpression;
import org.gemoc.ql.model.ql.BooleanValueType;
import org.gemoc.ql.model.ql.ConditionnalElement;
import org.gemoc.ql.model.ql.Expression;
import org.gemoc.ql.model.ql.IfExpression;
import org.gemoc.ql.model.ql.QlPackage;
import org.gemoc.ql.model.ql.QuestionDefinition;
import org.gemoc.ql.model.ql.ValueType;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class QLValidator extends AbstractQLValidator {
  public static final String INVALID_TYPE = "invalidType";

  @Check(CheckType.NORMAL)
  public void checkComputedQuestionExpressionType(final QuestionDefinition qd) {
    Expression _computedExpression = qd.getComputedExpression();
    boolean _tripleNotEquals = (_computedExpression != null);
    if (_tripleNotEquals) {
      final ValueType inferredValueType = ExpressionAspect.inferredValueType(qd.getComputedExpression());
      boolean _isCompatible = ValueTypeAspect.isCompatible(qd.getDataType(), inferredValueType);
      boolean _not = (!_isCompatible);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Expecting ");
        String _prettyPrintType = this.prettyPrintType(qd.getDataType());
        _builder.append(_prettyPrintType);
        _builder.append(" but expression type is ");
        String _prettyPrintType_1 = this.prettyPrintType(inferredValueType);
        _builder.append(_prettyPrintType_1);
        this.error(_builder.toString(), 
          QlPackage.Literals.QUESTION_DEFINITION__COMPUTED_EXPRESSION, 
          QLValidator.INVALID_TYPE);
      }
    }
  }

  @Check(CheckType.NORMAL)
  public void checkGuardExpressionType(final ConditionnalElement ce) {
    Expression _guard = ce.getGuard();
    boolean _tripleNotEquals = (_guard != null);
    if (_tripleNotEquals) {
      final ValueType inferredValueType = ExpressionAspect.inferredValueType(ce.getGuard());
      if ((inferredValueType == null)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Guard expression type cannot be inferred");
        this.error(_builder.toString(), 
          QlPackage.Literals.CONDITIONNAL_ELEMENT__GUARD, 
          QLValidator.INVALID_TYPE);
      } else {
        if ((!(inferredValueType instanceof BooleanValueType))) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Guard expression type is a ");
          String _prettyPrintType = this.prettyPrintType(inferredValueType);
          _builder_1.append(_prettyPrintType);
          _builder_1.append("  instead of a boolean");
          this.error(_builder_1.toString(), 
            QlPackage.Literals.CONDITIONNAL_ELEMENT__GUARD, 
            QLValidator.INVALID_TYPE);
        }
      }
    }
  }

  @Check(CheckType.NORMAL)
  public void checkIfExpressionGuardType(final IfExpression ifExpression) {
    Expression _condition = ifExpression.getCondition();
    boolean _tripleNotEquals = (_condition != null);
    if (_tripleNotEquals) {
      final ValueType inferredValueType = ExpressionAspect.inferredValueType(ifExpression.getCondition());
      if ((inferredValueType == null)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Condition expression type cannot be inferred");
        this.error(_builder.toString(), 
          QlPackage.Literals.IF_EXPRESSION__CONDITION, 
          QLValidator.INVALID_TYPE);
      } else {
        if ((!(inferredValueType instanceof BooleanValueType))) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Condition expression type is a ");
          String _prettyPrintType = this.prettyPrintType(inferredValueType);
          _builder_1.append(_prettyPrintType);
          _builder_1.append("  instead of a boolean");
          this.error(_builder_1.toString(), 
            QlPackage.Literals.IF_EXPRESSION__CONDITION, 
            QLValidator.INVALID_TYPE);
        }
      }
    }
    final ValueType thenInferredValueType = ExpressionAspect.inferredValueType(ifExpression.getThenExpression());
    if (((thenInferredValueType != null) && (ifExpression.getElseExpression() != null))) {
      final ValueType elseInferredValueType = ExpressionAspect.inferredValueType(ifExpression.getElseExpression());
      boolean _isCompatible = ValueTypeAspect.isCompatible(thenInferredValueType, elseInferredValueType);
      boolean _not = (!_isCompatible);
      if (_not) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("else type ");
        String _prettyPrintType_1 = this.prettyPrintType(elseInferredValueType);
        _builder_2.append(_prettyPrintType_1);
        _builder_2.append(" is not compatible with then type ");
        String _prettyPrintType_2 = this.prettyPrintType(thenInferredValueType);
        _builder_2.append(_prettyPrintType_2);
        this.error(_builder_2.toString(), 
          QlPackage.Literals.IF_EXPRESSION__ELSE_EXPRESSION, 
          QLValidator.INVALID_TYPE);
      }
    }
  }

  @Check(CheckType.NORMAL)
  public void checkBasicBinaryExpressionTypes(final BasicBinaryExpression binaryExpression) {
    final ValueType lhsType = ExpressionAspect.inferredValueType(binaryExpression.getLhsOperand());
    final ValueType rhsType = ExpressionAspect.inferredValueType(binaryExpression.getRhsOperand());
    ValueTypeAspect.isCompatible(lhsType, rhsType);
    if (((lhsType == null) || (!ValueTypeAspect.isCompatible(lhsType, rhsType)))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Incompatible types ");
      String _prettyPrintType = this.prettyPrintType(lhsType);
      _builder.append(_prettyPrintType);
      _builder.append(" and ");
      String _prettyPrintType_1 = this.prettyPrintType(rhsType);
      _builder.append(_prettyPrintType_1);
      _builder.append(" for operator ");
      String _name = binaryExpression.getOperator().getName();
      _builder.append(_name);
      this.error(_builder.toString(), 
        QlPackage.Literals.BASIC_BINARY_EXPRESSION__OPERATOR, 
        QLValidator.INVALID_TYPE);
    }
  }

  public String prettyPrintType(final ValueType valueType) {
    if ((valueType != null)) {
      StringConcatenation _builder = new StringConcatenation();
      String _name = valueType.getName();
      _builder.append(_name);
      _builder.append("(");
      String _name_1 = valueType.eClass().getName();
      _builder.append(_name_1);
      _builder.append(")");
      return _builder.toString();
    } else {
      return "null";
    }
  }
}
