/**
 * generated by Xtext 2.31.0
 */
package org.gemoc.qls.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.gemoc.ql.k3ql.k3dsa.ecore.EObjectAspect;
import org.gemoc.ql.model.ql.QuestionDefinition;
import org.gemoc.qls.model.qls.Import;
import org.gemoc.qls.model.qls.QLSModel;
import org.gemoc.qls.model.qls.QlsPackage;
import org.gemoc.qls.model.qls.QuestionReference;
import org.gemoc.qls.utils.QLSUtils;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class QLSValidator extends AbstractQLSValidator {
  public static final String INVALID_URI = "invalidURI";

  public static final String FORBIDDEN_MULTIPLE_USE = "forbiddenMultipleUse";

  @Check
  public void checkImport(final Import imp) {
    String _importURI = imp.getImportURI();
    boolean _tripleNotEquals = (_importURI != null);
    if (_tripleNotEquals) {
      boolean _startsWith = imp.getImportURI().startsWith("/");
      if (_startsWith) {
        String _importURI_1 = imp.getImportURI();
        String _plus = ("Invalid URI format " + _importURI_1);
        String _plus_1 = (_plus + ", maybe \"platform:\" prefix is missing");
        this.error(_plus_1, imp, 
          imp.eClass().getEStructuralFeature(QlsPackage.IMPORT__IMPORT_URI), QLSValidator.INVALID_URI);
      }
      final URI uri = QLSUtils.resolveImportURI(imp.getImportURI(), imp.eResource());
      boolean _exists = imp.eResource().getResourceSet().getURIConverter().exists(uri, null);
      boolean _not = (!_exists);
      if (_not) {
        this.error((("File " + uri) + " not found"), imp, 
          imp.eClass().getEStructuralFeature(QlsPackage.IMPORT__IMPORT_URI));
      }
    }
  }

  @Check
  public void checkQuestionReference(final QuestionReference qRef) {
    final Function1<QuestionReference, Boolean> _function = (QuestionReference qr) -> {
      QuestionDefinition _question = qr.getQuestion();
      QuestionDefinition _question_1 = qRef.getQuestion();
      return Boolean.valueOf(Objects.equal(_question, _question_1));
    };
    int _size = IteratorExtensions.size(IteratorExtensions.<QuestionReference>filter(Iterators.<QuestionReference>filter(EObjectAspect.<EObject>getContainerOfType(qRef, QLSModel.class).eAllContents(), QuestionReference.class), _function));
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("Cannot use question more than once in QLS sections", qRef, qRef.eClass().getEStructuralFeature(QlsPackage.QUESTION_REFERENCE__QUESTION), QLSValidator.FORBIDDEN_MULTIPLE_USE);
    }
  }
}
