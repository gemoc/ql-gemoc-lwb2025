/*
 * generated by Xtext 2.31.0
 */
package org.gemoc.qls.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.gemoc.ql.model.ql.BasicBinaryExpression;
import org.gemoc.ql.model.ql.BasicUnaryExpression;
import org.gemoc.ql.model.ql.BooleanValue;
import org.gemoc.ql.model.ql.BooleanValueType;
import org.gemoc.ql.model.ql.ConstantCall;
import org.gemoc.ql.model.ql.DateValue;
import org.gemoc.ql.model.ql.DateValueType;
import org.gemoc.ql.model.ql.DecimalValue;
import org.gemoc.ql.model.ql.DecimalValueType;
import org.gemoc.ql.model.ql.DefinitionGroup;
import org.gemoc.ql.model.ql.EnumerationCall;
import org.gemoc.ql.model.ql.EnumerationLiteral;
import org.gemoc.ql.model.ql.EnumerationValueType;
import org.gemoc.ql.model.ql.IfExpression;
import org.gemoc.ql.model.ql.IntegerValue;
import org.gemoc.ql.model.ql.IntegerValueType;
import org.gemoc.ql.model.ql.QLModel;
import org.gemoc.ql.model.ql.QlPackage;
import org.gemoc.ql.model.ql.Question;
import org.gemoc.ql.model.ql.QuestionCall;
import org.gemoc.ql.model.ql.QuestionDefinition;
import org.gemoc.ql.model.ql.QuestionGroup;
import org.gemoc.ql.model.ql.StringValue;
import org.gemoc.ql.model.ql.StringValueType;
import org.gemoc.ql.model.ql.ValueType;
import org.gemoc.ql.serializer.QLSemanticSequencer;
import org.gemoc.qls.model.qls.BooleanTypeStyle;
import org.gemoc.qls.model.qls.Import;
import org.gemoc.qls.model.qls.LabelStyle;
import org.gemoc.qls.model.qls.NumericTypeSpinnerStyle;
import org.gemoc.qls.model.qls.NumericTypeTextFieldStyle;
import org.gemoc.qls.model.qls.QLSModel;
import org.gemoc.qls.model.qls.QlsPackage;
import org.gemoc.qls.model.qls.QuestionReference;
import org.gemoc.qls.model.qls.QuestionStyle;
import org.gemoc.qls.model.qls.Section;
import org.gemoc.qls.model.qls.TextTypeStyle;
import org.gemoc.qls.services.QLSGrammarAccess;

@SuppressWarnings("all")
public class QLSSemanticSequencer extends QLSemanticSequencer {

	@Inject
	private QLSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == QlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case QlPackage.BASIC_BINARY_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getUnaryOrPrimaryExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getEqualExpressionRule()
						|| action == grammarAccess.getEqualExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getComparisionExpressionRule()
						|| action == grammarAccess.getComparisionExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getAdditionExpressionRule()
						|| action == grammarAccess.getAdditionExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getMultiplicationExpressionRule()
						|| action == grammarAccess.getMultiplicationExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()) {
					sequence_AdditionExpression_AndExpression_ComparisionExpression_EqualExpression_MultiplicationExpression_OrExpression(context, (BasicBinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBasicBinaryExpressionRule()) {
					sequence_BasicBinaryExpression(context, (BasicBinaryExpression) semanticObject); 
					return; 
				}
				else break;
			case QlPackage.BASIC_UNARY_EXPRESSION:
				if (rule == grammarAccess.getBasicUnaryExpressionRule()) {
					sequence_BasicUnaryExpression(context, (BasicUnaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getUnaryOrPrimaryExpressionRule()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getEqualExpressionRule()
						|| action == grammarAccess.getEqualExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getComparisionExpressionRule()
						|| action == grammarAccess.getComparisionExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getAdditionExpressionRule()
						|| action == grammarAccess.getAdditionExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()
						|| rule == grammarAccess.getMultiplicationExpressionRule()
						|| action == grammarAccess.getMultiplicationExpressionAccess().getBasicBinaryExpressionLhsOperandAction_1_0()) {
					sequence_UnaryExpression(context, (BasicUnaryExpression) semanticObject); 
					return; 
				}
				else break;
			case QlPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case QlPackage.BOOLEAN_VALUE_TYPE:
				sequence_BooleanValueType(context, (BooleanValueType) semanticObject); 
				return; 
			case QlPackage.CONSTANT_CALL:
				sequence_ConstantCall(context, (ConstantCall) semanticObject); 
				return; 
			case QlPackage.DATE_VALUE:
				sequence_DateValue(context, (DateValue) semanticObject); 
				return; 
			case QlPackage.DATE_VALUE_TYPE:
				sequence_DateValueType(context, (DateValueType) semanticObject); 
				return; 
			case QlPackage.DECIMAL_VALUE:
				sequence_DecimalValue(context, (DecimalValue) semanticObject); 
				return; 
			case QlPackage.DECIMAL_VALUE_TYPE:
				sequence_DecimalValueType(context, (DecimalValueType) semanticObject); 
				return; 
			case QlPackage.DEFINITION_GROUP:
				sequence_DefinitionGroup(context, (DefinitionGroup) semanticObject); 
				return; 
			case QlPackage.ENUMERATION_CALL:
				sequence_EnumerationCall(context, (EnumerationCall) semanticObject); 
				return; 
			case QlPackage.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case QlPackage.ENUMERATION_VALUE_TYPE:
				sequence_EnumerationValueType(context, (EnumerationValueType) semanticObject); 
				return; 
			case QlPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case QlPackage.INTEGER_VALUE:
				sequence_IntegerValue(context, (IntegerValue) semanticObject); 
				return; 
			case QlPackage.INTEGER_VALUE_TYPE:
				sequence_IntegerValueType(context, (IntegerValueType) semanticObject); 
				return; 
			case QlPackage.QL_MODEL:
				sequence_QLModel(context, (QLModel) semanticObject); 
				return; 
			case QlPackage.QUESTION:
				sequence_Question(context, (Question) semanticObject); 
				return; 
			case QlPackage.QUESTION_CALL:
				sequence_QuestionCall(context, (QuestionCall) semanticObject); 
				return; 
			case QlPackage.QUESTION_DEFINITION:
				sequence_QuestionDefinition(context, (QuestionDefinition) semanticObject); 
				return; 
			case QlPackage.QUESTION_GROUP:
				sequence_QuestionGroup(context, (QuestionGroup) semanticObject); 
				return; 
			case QlPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case QlPackage.STRING_VALUE_TYPE:
				sequence_StringValueType(context, (StringValueType) semanticObject); 
				return; 
			case QlPackage.VALUE_TYPE:
				sequence_ValueType_Impl(context, (ValueType) semanticObject); 
				return; 
			}
		else if (epackage == QlsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case QlsPackage.BOOLEAN_TYPE_STYLE:
				sequence_BooleanTypeStyle(context, (BooleanTypeStyle) semanticObject); 
				return; 
			case QlsPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case QlsPackage.LABEL_STYLE:
				sequence_LabelStyle(context, (LabelStyle) semanticObject); 
				return; 
			case QlsPackage.NUMERIC_TYPE_SPINNER_STYLE:
				sequence_NumericTypeSpinnerStyle(context, (NumericTypeSpinnerStyle) semanticObject); 
				return; 
			case QlsPackage.NUMERIC_TYPE_TEXT_FIELD_STYLE:
				sequence_NumericTypeTextFieldStyle(context, (NumericTypeTextFieldStyle) semanticObject); 
				return; 
			case QlsPackage.QLS_MODEL:
				sequence_QLSModel(context, (QLSModel) semanticObject); 
				return; 
			case QlsPackage.QUESTION_REFERENCE:
				sequence_QuestionReference(context, (QuestionReference) semanticObject); 
				return; 
			case QlsPackage.QUESTION_STYLE:
				sequence_QuestionStyle(context, (QuestionStyle) semanticObject); 
				return; 
			case QlsPackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case QlsPackage.TEXT_TYPE_STYLE:
				sequence_TextTypeStyle(context, (TextTypeStyle) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeStyle returns BooleanTypeStyle
	 *     BooleanTypeStyle returns BooleanTypeStyle
	 *
	 * Constraint:
	 *     booleanStyleKind=BooleanStyleKind
	 * </pre>
	 */
	protected void sequence_BooleanTypeStyle(ISerializationContext context, BooleanTypeStyle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlsPackage.Literals.BOOLEAN_TYPE_STYLE__BOOLEAN_STYLE_KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlsPackage.Literals.BOOLEAN_TYPE_STYLE__BOOLEAN_STYLE_KIND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanTypeStyleAccess().getBooleanStyleKindBooleanStyleKindEnumRuleCall_2_0(), semanticObject.getBooleanStyleKind());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlsPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlsPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_2_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LabelStyle returns LabelStyle
	 *
	 * Constraint:
	 *     (italic?='italic'? bold?='bold'?)
	 * </pre>
	 */
	protected void sequence_LabelStyle(ISerializationContext context, LabelStyle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeStyle returns NumericTypeSpinnerStyle
	 *     NumericTypeStyle returns NumericTypeSpinnerStyle
	 *     NumericTypeSpinnerStyle returns NumericTypeSpinnerStyle
	 *
	 * Constraint:
	 *     step=EDouble?
	 * </pre>
	 */
	protected void sequence_NumericTypeSpinnerStyle(ISerializationContext context, NumericTypeSpinnerStyle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeStyle returns NumericTypeTextFieldStyle
	 *     NumericTypeStyle returns NumericTypeTextFieldStyle
	 *     NumericTypeTextFieldStyle returns NumericTypeTextFieldStyle
	 *
	 * Constraint:
	 *     {NumericTypeTextFieldStyle}
	 * </pre>
	 */
	protected void sequence_NumericTypeTextFieldStyle(ISerializationContext context, NumericTypeTextFieldStyle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QLSModel returns QLSModel
	 *
	 * Constraint:
	 *     (imports+=Import* styledQLModel=[QLModel|QualifiedName] questionStyles+=QuestionStyle* sections+=Section*)
	 * </pre>
	 */
	protected void sequence_QLSModel(ISerializationContext context, QLSModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SectionContent returns QuestionReference
	 *     QuestionReference returns QuestionReference
	 *
	 * Constraint:
	 *     question=[QuestionDefinition|QualifiedName]
	 * </pre>
	 */
	protected void sequence_QuestionReference(ISerializationContext context, QuestionReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QlsPackage.Literals.QUESTION_REFERENCE__QUESTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QlsPackage.Literals.QUESTION_REFERENCE__QUESTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQuestionReferenceAccess().getQuestionQuestionDefinitionQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(QlsPackage.Literals.QUESTION_REFERENCE__QUESTION, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QuestionStyle returns QuestionStyle
	 *
	 * Constraint:
	 *     (styledQuestion=[QuestionDefinition|QualifiedName] labelStyle=LabelStyle? typeStyle=TypeStyle?)
	 * </pre>
	 */
	protected void sequence_QuestionStyle(ISerializationContext context, QuestionStyle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Section returns Section
	 *     SectionContent returns Section
	 *
	 * Constraint:
	 *     (title=STRING sectionContents+=SectionContent*)
	 * </pre>
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeStyle returns TextTypeStyle
	 *     TextTypeStyle returns TextTypeStyle
	 *
	 * Constraint:
	 *     multiline?='multiline'?
	 * </pre>
	 */
	protected void sequence_TextTypeStyle(ISerializationContext context, TextTypeStyle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
