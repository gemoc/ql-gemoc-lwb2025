
// used to detect if a document is included in readme master
:included_in_readme: true

:imagesdir: docs/img

= ql-gemoc-lwb2025
Questionnaire Language DSL implemented using the GEMOC Studio as a solution for the Language Workbench Challenge 2025 (LWB2025)

:toc:

== Challenge Participation and Context

This document presents the implementation of the "Questionnaire Language" proposed in the https://github.com/judithmichael/lwb25[Language Workbench Challenge 2025]. This challenge, as a continuation of the Language Workbench Contest initiated in 2013, aims to demonstrate the capabilities of modern language workbenches by modeling and implementing a relatively simple but representative domain-specific language (DSL).

The GEMOC Studio integrates and assembles several major existing Eclipse technologies for language engineering, including:

* *EMF* (Eclipse Modeling Framework) for metamodeling and model management,
* *https://eclipse.dev/sirius/[Sirius Desktop]* for the definition of graphical editors,
* *https://www.eclipse.org/Xtext/documentation/[Xtext]* for the specification of textual editors.

Readers may refer to the respective official documentation of these tools for detailed usage information.

Beyond this integration, the GEMOC Studio extends these capabilities by providing:

* Several *semantic modeling frameworks* for defining the execution behavior of models (e.g., K3, ALE for sequential semantics; MoCCML for concurrency modeling),
* *Execution engines* and *engine addons* that enable advanced runtime services such as model animation, debugging, timeline visualization, state space exploration, and concurrency control,
* *Coordination mechanisms* for combining multiple models or languages at execution time.

This architecture allows users to not only define the structure and editors of a DSL but also to specify, execute, and debug its operational semantics.

Given the diversity of capabilities offered by the GEMOC Studio, specific tools and approaches were deliberately chosen to showcase the breadth of GEMOC’s potential. The design decisions made in this implementation aim not only to address the technical requirements of the Questionnaire Language but also to illustrate various features of the GEMOC Studio. In some cases, alternative choices might have been more appropriate for a production-ready language implementation, but demonstrating the versatility of the workbench was prioritized.

The remainder of this document is organized as follows:

* *Quick Start Instructions*: A brief guide to install the necessary tools, import the project, and launch the Questionnaire Language execution. This section allows readers to quickly verify the implementation without going into technical details.

* *Selected Tools, Approaches, and Design Rationale*: A description of the tools and modeling approaches selected within the GEMOC Studio environment, combined with explanations of the main motivations behind these choices.

* *Modeling and Implementation Overview*: A detailed description of the abstract syntax, concrete syntax, and behavioral semantics.

* *Demonstration of Execution and Tooling Support*: An illustration of the execution features enabled by the implementation, including screenshots and explanations of the available tooling.

* *Additional GEMOC Studio features illustrated in other case studies*: Although not directly demonstrated in this implementation, other capabilities of the GEMOC Studio — such as advanced concurrency modeling, state space exploration, live model-execution synchronization, and multi-language coordination — are highlighted through complementary case studies and example languages.


== Repository Structure

The repository is organized as follows:

* `plugins/`
** Contains the source code for the language definition and execution support.
** Subfolders:
*** `commons/`: Utility projects reused across different parts of the implementation.
*** `k3ql/`: Projects defining the behavioral semantics of the Questionnaire Language using the K3 framework (GEMOC Sequential Engine).
*** `ql/`: Projects defining the structural (metamodels) and syntactical (editors) aspects of the Questionnaire Language (including Xtext grammar and Sirius diagrams).

[NOTE]
====
Each of these folders contains **multiple Eclipse plug-in projects** that must be imported individually into the GEMOC Studio.
====

* `model_examples/`
** Example models conforming to the Questionnaire Language.
** Includes both textual models (`.ql`) and corresponding graphical representations (`.aird`).

* `docs/`
** Documentation files for the project (such as metamodel diagrams and development notes).

* `releng/`
** Maven/Tycho configuration for building and managing the project as an Eclipse-based product.

* `README.adoc`
** Entry point documentation, including context, quick start, and technical explanations.

* `.github/`, `.mvn/`, `.settings/`
** Standard GitHub Actions, Maven, and Eclipse settings for automation and environment configuration.



== Quick start

This section provides the basic instructions to install the *Language Workbench* with the language definitions for the challenge, and to run the *Modeling Workbench* with example models conforming to the languages.

=== Setting up the Language Workbench with Questionnaire Language Definitions

Requirements:

* Java 17 or higher
* A GEMOC Studio downloaded from http://gemoc.irisa.fr/pub/studio/gemoc_studio_2024_11_12/

NOTE: This is the version used to develop the languages for the challenge. A more recent version may be available from https://gemoc.org/download.html.

NOTE: Documentation for the GEMOC Studio is available https://download.eclipse.org/gemoc/docs/nightly/index.html[here^].

* A `git clone` of the challenge repository: https://github.com/gemoc/ql-gemoc-lwb2025
  (This can also be performed directly from within GEMOC Studio.)

Steps:

* Unzip or untar the downloaded GEMOC Studio.
* Start GEMOC Studio.

NOTE: In this context, we refer to this initial workspace as the *Language Workbench*, since it contains the language definitions for the challenge.

* Import all projects contained in the following folders of the cloned repository:
  - `plugins/commons/`
  - `plugins/k3ql/`
  - `plugins/ql/`

TIP: In GEMOC Studio, use _File_ > _Import..._ > _General_ > _Existing Projects into Workspace_, then select each folder above to import all contained projects at once.

=== Setting up the Modeling Workbench to Use the Questionnaire Language

From the Language Workbench instance of GEMOC Studio, a second instance (the *Modeling Workbench*) must be launched where the developed language plugins will be deployed.

Steps:

* In GEMOC Studio, open the menu: _Run_ > _Run Configurations..._
* Under _Eclipse Application_, select _Launch Runtime Eclipse LWB2025_ and click _Run_.

NOTE: This launch configuration is available if the `org.gemoc.ql.k3ql.xdsml` project has been correctly imported.

[NOTE]
====
Although for demonstration purposes we start the Modeling Workbench from the Language Workbench, it is possible to package the DSL for standalone use by end users. 
See: https://download.eclipse.org/gemoc/docs/releases/3.6.0/userguide-lw-deploy-language.html#distribute-language-for-model-designer-section
====

* In the opened Modeling Workbench, import the projects located in the `model_examples/` folder.

=== Model Editing

* Edit the provided models using the textual editor (`*.ql` files).

.Modeling Workbench textual editor opened on the HouseOwning example
image::mwb_houseOwning_textual_editor.png[Modeling Workbench textual editor opened on the HouseOwning example]

* Visualize models using the graphical editor by opening the corresponding `*.aird` files associated with the `.ql` files.

.Modeling Workbench graphical editor opened on the HouseOwning example
image::mwb_houseOwning_graphical_editor_layers.png[Modeling Workbench graphical editor opened on the HouseOwning example]

[NOTE]
====
For the challenge, we haven't implemented Sirius edition tool (palette) except interactions with the Xtext editor. 
So edition within Sirius views is currently limited to its property view.
====

=== Model Execution

To execute a model (i.e., to start a questionnaire):

* Open the view `QL Form Browser View`:
  - Menu _Window_ > _Show View_ > _Other_ > _Questionnaire Language_ > _QL Form Browser View_.
* Start the model execution:
  - Menu _Run_ > _Run Configurations..._ > _Executable GEMOC with Java engine_.
  - Use one of the predefined launch configurations for the provided models, or create your own (make sure to activate the `QL Form Browser View` addon in the Engine Addons tab).

This launches the questionnaire execution inside the `QL Form Browser View` and, if available, also triggers graphical animation of the model with Sirius.

The Sirius-based graphical animation offers a complementary visualization of the running questionnaire by displaying runtime information directly on the model:
- The current value of each question is dynamically displayed.
- The visual appearance of questions (such as color changes) is updated in real time to reflect their visibility status (e.g., whether a question is currently shown to the user or hidden based on the model's logic).

.Graphical animation of a running questionnaire model in Sirius, showing dynamic updates of question values and visibility states during execution
image::mwb_projectBudget_run.png[Graphical animation of a running questionnaire model in Sirius, showing dynamic updates of question values and visibility states during execution]

=== Model Debugging

To debug a model (i.e., to start a questionnaire in debug mode):

* Open the Debug perspective:
  - Menu _Window_ > _Perspective_ > _Open Perspective_ > _Debug_.
* Open the view `QL Form Browser View` as described above.
* Start the model in debug mode:
  - Menu _Debug_ > _Debug Configurations..._ > _Executable GEMOC with Java engine_.
  - Use one of the predefined launch configurations or create your own.


In addition to the Sirius-based graphical animation available during execution, several debugging-specific views and actions are provided. These features operate at the level of the *Questionnaire Language* (i.e., they allow debugging the model itself, not the underlying Java code):

- **Stack View**: Displays the current execution stack when the execution is paused.
- **Variables View**: Shows the current runtime values of the model elements.
- **Step-by-Step Execution**: Enables manual control to execute one step at a time through the model behavior.
- **Model Breakpoints**: Allows breakpoints to be set directly on model elements (Right-click a model element in the Sirius view to toggle a breakpoint; execution will pause when a related model step occurs).
- **Current Element Highlighting**: Highlights the model element currently being executed (decorated in yellow in the Sirius graphical editor and selected in the textual Xtext editor).
- **Multidimensional Timeline (optional)**: If enabled in the launch configuration (Engine Addons tab), the *Multidimensional Timeline* view visualizes the history of runtime data changes over time in a structured and synchronized manner.

These capabilities together offer a rich environment for observing, inspecting, and controlling the execution of the questionnaire models at a high level of abstraction.

.Modeling Workbench with the HouseOwning example pause after a click on hasSoldHouse and while rendering the questions (only 2 out of the 3 optional questions have been enabled and displayed at this point)
image::mwb_houseOwning_debug_paused_when_updating_value_from_ui_hasSoldHouse.png[Modeling Workbench with the HouseOwning example pause after a click on hasSoldHouse and while rendering the questions (only 2 out of the 3 optional questions have been enabled and displayed at this point)]


== Selected Tools, Approaches, and Design Rationale

For this implementation, we selected a combination of GEMOC Studio tools and modeling approaches to illustrate both essential and advanced capabilities of the platform. The choices were guided by a balance between simplicity, modularity, and demonstration value for the challenge.

=== DSL Edition

* **EMF (Eclipse Modeling Framework)** was used to define the metamodel, and automatically provide a basic *tree-based editor* for model instances (offering a structured syntax).
* **Xtext** was employed to define a more user-friendly *textual syntax* for questionnaire models, integrated directly into the Eclipse environment.
* **Sirius Desktop** was used to define *graphical visualizations*:
  - A *Basic Object Diagram* was automatically generated using the GEMOC wizard. Inspired by UML Object Diagrams, this view is verbose and generic, but can serve as a starting point for more specialized diagrams.
  - A manually crafted *QLDiagram* was designed to offer a more domain-specific and readable visualization of questionnaires.

[NOTE]
====
In this implementation, the Sirius graphical editors focus on visualization rather than full model editing: edition actions (e.g., palette tools) were not implemented, and editing remains limited to the property view or synchronized editing through the Xtext textual editor.
====

=== DSL Semantics

* A **K3-based sequential execution engine** defines the operational semantics of the questionnaire models. https://www.kermeta.org/[K3 language] offers a simple yet powerful metaprogramming approach by weaving behavioral aspects directly onto EMF model elements.

NOTE: As K3 language is actually a set of annotations for the https://eclipse.dev/Xtext/xtend/[Xtend] that compiles to java, for GEMOC this is also refered as GEMOC Java Engine.

* **Separation of UI and execution semantics** was emphasized through the use of the GEMOC Engine Addon mechanism:
  - A custom Engine Addon (`QLFormBrowserView`) was developed to handle the display and interaction of the questionnaire UI, without mixing UI concerns into the execution semantics.
  - This addon listens to runtime events published by the execution engine, enabling dynamic updates of a web-based form embedded in an Eclipse view.

[IMPORTANT]
====
The https://download.eclipse.org/gemoc/docs/nightly/_contributing.html#dev-new-addonsEngine Addon mechanism used here reflects one of GEMOC Studio’s core strengths: it enables coordination between multiple concurrent runtime models or external systems. In this case, the questionnaire execution and the UI form are treated as loosely coupled artifacts, coordinated dynamically through the engine events.
====

=== Edition and Semantic Customizations

* **Debug layers** were automatically generated for both Sirius diagrams, providing support for execution highlighting, breakpoints, and stepping during model debugging.
* **Animation layers** were manually designed for the *QLDiagram*, enabling visual feedback during execution (such as dynamic value display and question visibility indication).

=== Resulting Language

The resulting language and its associated tooling support are named **K3QL**.  
*K3QL* encapsulates the questionnaire domain-specific modeling constructs, textual and graphical editors, execution semantics, and runtime interaction features defined through the approaches outlined above.



== Modeling and Implementation Overview

//A detailed description of the abstract syntax, concrete syntax, and behavioral semantics.

=== Abstract Syntax

The abstract syntax of the QL language is capture using an Ecore metamodel that is defined in the `org.gemoc.ql.model` plugin.

It is organized as follow:

.QL main class diagram
[#img-ql-main-class-diagram]
[caption="Figure 1: ",link=https://github.com/gemoc/ql-gemoc-lwb2025/blob/main/plugins/ql/org.gemoc.ql.model/model/img/ql main class diagram.jpg]
image::../../plugins/ql/org.gemoc.ql.model/model/img/ql main class diagram.jpg[QL main class diagram,800]


.Named elements class diagram
[#img-named-elements-class-diagram]
[caption="Figure 1: ",link=https://github.com/gemoc/ql-gemoc-lwb2025/blob/main/plugins/ql/org.gemoc.ql.model/model/img/ql named elements class diagram.jpg]
image::../../plugins/ql/org.gemoc.ql.model/model/img/ql named elements class diagram.jpg[Named elements class diagram,800]


.Expression class diagram
[#img-expression-class-diagram]
[caption="Figure 1: ",link=https://github.com/gemoc/ql-gemoc-lwb2025/blob/main/plugins/ql/org.gemoc.ql.model/model/img/ql expression class diagram.jpg]
image::../../plugins/ql/org.gemoc.ql.model/model/img/ql expression class diagram.jpg[Expression class diagram,800]

.Types class diagram
[#img-types-class-diagram]
[caption="Figure 1: ",link=https://github.com/gemoc/ql-gemoc-lwb2025/blob/main/plugins/ql/org.gemoc.ql.model/model/img/ql type class diagram.jpg]
image::../../plugins/ql/org.gemoc.ql.model/model/img/ql type class diagram.jpg[Types class diagram,800]

<<img-ql-main-class-diagram>> shows that `Question` conforms to  a `QuestionDefinition`. A set of `Question` is organized in group and sub-group that may have a guard. This guard indicates when the questions in the group must be displayed.
`QuestionDefinition` may be calculated by evaluating an `Expression`.

NOTE: The name `Question` and `QuestionDefinition` is arguable in case of calculation. A refactoring may be done later in order to enhance the readability of the abstract syntax.

A `QuestionDefinition` data is typed  by a `ValueType` that can take one of the primitive type as shown in <<img-types-class-diagram>>.


`ValueType` are defined with the Questionnaire (QLModel) and may define a `unit` and additional attributes such as min or max. 

`Expression` allows to support evaluation of `Value` that can come from different kind of expression: `BinaryExpression` for expression having left hand side and right hand side, `UnaryExpression` for operators such as `Not` or `Minus`.

the `IfExpression` allows to create conditional expression return the evaluation of the `thenExpression` or the `elseExpression` depending on the evaluation of the `condition`.

The runtime data has been directly added into the QL.ecore: `QuestionDefinition.currentValue`, `QuestionDefinition.isDisplayed`, and `QLModel.canSubmit`. These data aren't intended to be directly edited by the user but used by the interpreter. They have the annotation `aspect` in order to identify them in the ecore file.

[NOTE]
====
Some techniques exist to define these runtime data separately from the QL.ecore:

* by weaving ecore models using http://melange.inria.fr[Melange] but this would have made the projects more complex due to the required conversion. (see. https://download.eclipse.org/gemoc/docs/nightly/userguide-lw-create-language-define-syntaxes.html#section-melange-editor and http://melange.inria.fr)

* by creating a separate metamodel that references the elements in QL.ecore, as a counter part, the code for the behavior would have been a bit less readable.
====



=== Concrete Syntax

Three editors are provided: the EMF tree editor, the XText textual editor, and the Sirius graphical editor


==== EMF tree editor
It was not modified much from its initial generation except for some minor enhancement  about the model element labels and icons.

It is composed of the plugins: `org.gemoc.ql.model.edit` and `org.gemoc.ql.model.editor`

TIP: `org.gemoc.ql.model.edit` is actually reused in several other editors and Eclipse views, such as the Sirius editor and the outline view.

==== XText textual editor

It is composed of the plugins: `org.gemoc.ql.xtext`, `org.gemoc.ql.xtext.ide`, and `org.gemoc.ql.xtext.ui`.

The `QL.xtext` file defines a user friendly grammar allowing support of qualified names, expressions, ...

It provides a modern textual editor with syntax coloring, code completion, error reporting, ...

It also provides a framework for quick fixes, validation, renaming, hovering, ...  A more complete list of feature is available in this https://eclipse.dev/Xtext/documentation/310_eclipse_support.html[XText documentation section].

For the challenge, in addition to the grammar, we also have slightly customized the formatting support.

==== Sirius Graphical editor

It is composed of the plugin: `org.gemoc.ql.design`.

It provides 2 diagrams:

* A *Basic Object Diagram* was automatically generated using the GEMOC wizard. Inspired by UML Object Diagrams, this view is verbose and generic, but can serve as a starting point for more specialized diagrams.
* A manually crafted *QLDiagram* was designed to offer a more domain-specific and readable visualization of questionnaires.

Sirius provides a way to define a mapping between visual elements (Node, Edge) and the abstract syntax concepts. Then it interpret this mapping in order to provide
  
Each diagram use the notion of _Layer_ in order to easily switch on or off  some customization.

For example the QLDiagram, proposes a `Typing` layer that shows the link between `Question` and `QuestionDefinition`.

The `Debug` layer has been generated by GEMOC. It allows to set/remove breakpoints, and allow to conditional styling during debug pause (ie. highlight the element in the diagram corresponding to selection in the stack view)

It also proposes an `Animation` layer. It is activated during model execution. It changes the color of the `Question` and `QuestionDefinition` to grey is they aren't displayed and add fields to display the current value of the questions.

TIP: Sirius provides several kind of representations. In the challenge, we used the Diagram representation, but other might be useful too see https://eclipse.dev/sirius/doc/specifier/Sirius%20Specifier%20Manual.html[Sirius Specifier Manual]


=== Behavioral Semantics

==== Core Execution Semantics

The execution semantic is defined in the `org.gemoc.ql.k3ql.k3dsa` plugins.

The operational semantics of QL are defined in the files `qlAspects.xtend`. This file which employs http://www.kermeta.org/[Kermeta 3 (K3)] and the https://en.wikipedia.org/wiki/Interpreter_pattern[Interpreter Design Pattern] to describe the dynamic behavior of QL models.
Its contents is woven into the metamodel of your executable DSL. In this file, you have aspects for all classes of your metamodel. Some of these aspects use annotations to define execution functions or entry points.

*Execution Functions*:

The Execution Functions define how the Execution Data evolve during the execution of the model. Execution Functions can be implemented by defining the body of a method. These methods must be annotated with the *@Step* annotation. Whenever a method with an `@Step` annotation returns, the changes in the model will be applied (via a transaction) to the resource. This means that the changes will be visible from an animator. K3 supports nested `@Step` annotation calls so that changes in the model will be applied when entering and leaving methods having these annotations.

*Entry Points*:

The GEMOC sequential engines uses methods annotated with *@Main* as entry points to model execution. This annotation must be placed on operations applicable to model elements considered as the model starting point. 

Additionally, a function annotated with *@InitializeModel* will be used to capture any argument passed by the launcher in order to initialize the runtime data if necessary.

For the challenge, the entry point is a `QLModel` element.


The logic in QL implementation is as follow:

* The main method is simply a loop that alternates question rendering requests, wait for user input, computation of value for computed questions.
* When the submit button has been pushed, it ends by performing a basic serialization of the whole model, including the runtime data (ie. the answers)

Question rendering requests ensures via guard evaluation that only `Question` in group where the guard is true will be rendered.

The concrete rendering in the UI is handled by an engine addon that captures the events `Question.show()` and the event `QLModel.updateSubmitButtonStatus()`.
Similarly, the wait for user input is also handled by the engine addon that captures the event `QLModel.waitUserInput()`. It pauses the execution until the UI has some event.
The events `QLModel.readSubmitButtonStatus()` and  `QuestionDefinition.updateCurrentValueFromUI()` are also captured by the addon. They modify the runtime data in the model.



==== UI 

TODO: Separation of the UI/Addon
In order to provide separation of the core execution semantics and the UI, the UI has been defined as an engine addon in the `org.gemoc.ql.k3based.addons` plugin.

When activated in the launch configuration, addons listen for the engine events. 

Thus, the methods in the class `QLFormBrowserViewAddon` will be called on specific engine events.

In this implementation, most  of the work is done while capturing the `aboutToExecuteStep` engine event. I.e. before a method annotated with *@Step* is called.
All addon API methods provide access to the engine, the EMF model including its runtime data if they have been defined using EMF, and details about the event that has been triggered. 
It is then easy, depending on the event, to read model runtime data in order to do some action in the UI or conversely, apply UI changes to the model runtime data

Call the these method is atomic and pauses the execution. This is handy to implement the `QLModel.waitUserInput()` step.


[TIP]
====

Most GEMOC features are based on this addon API. 
For example, the debugger is an addon that pauses the execution when a given condition (a breakpoint) is reached. 
Timelines listen to model changes to store relevant information (runtime data changes, events, ...) in order to build the view, etc.

====

[TIP]
====

In some situations, when many addon are activated, the order in which they are called may provide non intuitive behavior. GEMOC allows to 
https://download.eclipse.org/gemoc/docs/nightly/_contributing.html#_controling_call_to_addon[control the call to addon] by implementing the `getAddonSortingRules` method.

====

As a concrete UI, the implementation provides an html web form  that is embedded in an Eclipse view. Data exchange between Eclipse and the web page is achieved using the `swt.Browser` class as it allows to call javascript methods in the page or react to javascript call.

The rendering of the QL form is then performed by writing in an html div when then `Question.show()` event is received. The same principle applies for the other events tha must interact with the UI. 


[TIP]
====

As this is an addon, we can imagine to implement this in many other ways (web protocol, java awt, java swing, javafx, ...) and switch between them by activating them in the launch configuration. 

====

== Demonstration of Execution and Tooling Support
// An illustration of the execution features enabled by the implementation, including screenshots and explanations of the available tooling.


[TODO]
==== 

Omniscient Debugging and Execution Tracing

the GEMOC Studio's omniscient debugging capabilities

These features allow users to:

- Navigate through execution traces both forward and backward.
- Inspect the state of models at any point in the execution.
- Set breakpoints and observe variable changes over time.

====

.Debug of a ProjectBudget example model paused after enabling the requireDesignAndUX question (with MultiDimentional data timeline enabled)
[#img-mwb_projectBudget_debug_timeline_paused_after_enabling_designUX_checkbox]
image::mwb_projectBudget_debug_timeline_paused_after_enabling_designUX_checkbox.png[mwb_projectBudget_debug_timeline_paused_after_enabling_designUX_checkbox,800]

== Additional GEMOC Studio features illustrated in other case studies

Beyond the features demonstrated in the K3QL implementation, the GEMOC Studio offers advanced capabilities that have been showcased in other case studies and tutorials. While these features are not used directly in the context of the Questionnaire Language defined for the challenge, they are important to highlight in the context of evaluating the GEMOC Studio as a language workbench. They illustrate powerful and often unique capabilities—such as explicit concurrency modeling, coordination of multiple DSMLs, and advanced execution analysis—that are especially valuable when engineering complex or interacting languages. These aspects reinforce the strength and flexibility of the GEMOC approach, even beyond the scope of this specific challenge use case.


=== Concurrency Modeling with MoCCML

The GEMOC Studio supports advanced concurrency modeling through the Model of Concurrency and Communication Modeling Language (MoCCML). This capability allows language designers to formally specify concurrency constraints independently of a language's operational semantics. The result is a modular and analyzable approach to handling concurrent behaviors in domain-specific modeling languages.

MoCCML is based on defining *logical relationships between events*—such as precedence, mutual exclusion, and causal dependencies—without prescribing how the behavior is implemented imperatively. This is particularly useful for domains such as reactive systems, embedded control, or human-machine interaction, where concurrency and timing are central.

When a DSL allows several elements to execute independently, it may naturally give rise to multiple valid execution orders. For instance, if two actions A and B are unrelated by semantics, then both the execution order A → B and B → A—or even a simultaneous execution—can be considered correct. Without a formal concurrency specification, such behavior remains implicit, making it harder to predict, debug, or analyze. MoCCML provides the means to make these concurrency relationships explicit.

A typical development flow includes:

- Defining *execution steps* in the behavioral semantics (e.g., via methods in K3). Unlike `@Step` in the sequential engine, these methods must be atomic and cannot be nested. If nesting is required, you need to split them in atomic parts. In GEMOC, they are called `DSA` (Domain Specific Action)
- Declaring relevant *event* definition corresponding to those execution steps in the context of the DSL metaclasses. In GEMOC, they are called `DSE` (Domain Specific Event)
- Writing MoCCML models and ECL constraints to express concurrency constraints between events.
- Launching model execution in GEMOC Studio using the MoCCML engine.

Once in place, these models enable:

- Executions that respect specified concurrency constraints.
- Visualization of partially ordered execution traces.
- Usage of the *Multibranch Timeline View* to inspect concurrent behavior and temporal properties. This view allows omniscient debugging by effectively navigating backward in the execution trace and branch to alternative concurrent possible execution.
- Step-by-step debugging that reflects both behavioral logic and concurrency control.
- Generate the complete state space of a model.
- Analyze possible execution paths.
- Identify deadlocks and unreachable states.

This technique is illustrated in several case studies and tutorials, such as the ICSA 2017 tutorial (https://github.com/gemoc/ICSA2017Tutorial), the MODELS 2017 tutorial (https://github.com/gemoc/MODELS2017Tutorial), and the dedicated tutorial “Weave Domain-Specific Concurrency Constraints Into Your DSL!” (https://gemoc.org/weave-domain-concurrency-into-your-dsl.html).


.Concurrency MultiBranch Timeline on a FSM model
[#img-concurrency-multibranchTime]
image::concurrency_multibranchTime.png[Concurrency example from MODELS 2017 tutorial,800]

Figure <<img-concurrency-multibranchTime>>, taken from the MODELS 2017 tutorial, illustrates the *Multibranch Timeline View* applied to a concurrent FSM model. It highlights key features of the view and the concurrent engine:

* *Blue dots* represent the main sequence of selected combinations of simultaneous events during the execution trace.
* *Green dots* indicate alternative combinations of events that were also valid at a given point, offering insight into possible concurrent interleavings.
* The timeline also supports *backtracking and branching*, allowing users to jump back to a previous decision point and explore an alternative path of execution, making it possible to analyze multiple valid behaviors of a concurrent system.



MoCCML-based concurrency modeling exemplifies one of GEMOC Studio’s distinctive strengths: allowing DSL designers to explicitly and modularly define how concurrency should behave, enabling more robust and analyzable modeling tools.


=== Behavioral Coordination with BCOoL

The *GEMOC Studio* offers a unique and powerful capability for coordinating the behavior of models written in different *Domain-Specific Modeling Languages (DSMLs)*. This is achieved through *BCOoL* — the Behavioral Coordination Operator Language. BCOoL enables language designers to explicitly define how models from different DSMLs should interact at runtime, making it a key tool for supporting *multi-language modeling* in complex systems.

// Why Coordination Matters

When engineering complex systems, different concerns (e.g., control logic, physical simulation, user interaction) are often best expressed using different DSMLs. However, executing and analyzing such systems jointly requires these models to be *coordinated*: their behaviors must be synchronized according to precise rules. Without this, inconsistencies or timing mismatches may arise during execution.

// What BCOoL Provides

BCOoL offers:

* *Formal definition of coordination operators* between events produced by different DSMLs (e.g., synchronizing a state change in a controller with a signal in a simulator).
* *Model-driven generation* of coordination logic that is reusable and automatically applicable across different models.
* *Integration with GEMOC's runtime execution framework*, enabling the execution of coordinated multi-language models.

Importantly, this integration is made possible by the underlying *GEMOC Framework Engine API*. At runtime, each language is extended through *Engine Addons*, which allow models to emit and respond to coordination events. BCOoL-generated coordination logic is deployed as such addons, enabling synchronized execution across independently defined engines.


// Key Concepts and Implementation Flow

BCOoL builds on three core concepts:

. *Events as a coordination interface*: Each DSML exposes a set of meaningful runtime events (called *DSA* — Domain-Specific Actions — in GEMOC) that can be coordinated. These are typically defined during the implementation of the DSML's behavioral semantics.
. *Coordination Operators*: Coordination logic is written as BCOoL specifications, where language designers declare synchronization rules (e.g., "when event A in language L1 occurs, event B in language L2 must follow").
. *Execution Model Coordination*:
.. BCOoL specifications are compiled into *Coordination Models*.
.. These are woven into a *Coordinated Execution Engine* that integrates the event streams of the involved DSMLs.
.. At runtime, GEMOC Studio uses this coordination model to control the interleaving and synchronization of the models' behaviors.

*Example: Synchronizing Timed Finite State Machines (TFSMs)*

A canonical example of BCOoL's power is shown in the BCOoL tutorial:

https://gemoc.org/BCOoL/

Two DSMLs — each representing *Timed Finite State Machines (TFSMs)* — are coordinated so that one FSM can trigger transitions in the other. In this case:

* Events corresponding to state transitions are exposed by both DSMLs.
* BCOoL is used to define that a transition in FSM1 causes (or must follow) a transition in FSM2.
* A coordinated execution engine is generated and used to simulate both FSMs in synchronization, respecting the declared rules.

This example demonstrates how BCOoL helps maintain *modularity* (languages remain separate) while enabling *behavioral integration* across models.

// Runtime Views and Debugging

When executing coordinated models in GEMOC Studio:

* The *Multidimensional Timeline View* is particularly helpful to understand and debug coordination, as it shows how events across languages align and interleave over time.
* Standard debugging tools (breakpoints, step-by-step execution, etc.) are also applicable to coordinated models, allowing inspection at both the individual DSML and system level.

// Value for Language Workbenches

BCOoL exemplifies a rare and highly valuable feature in language workbenches: it enables *reusable, model-driven coordination* across heterogeneous languages. This goes far beyond integrating APIs or defining ad-hoc glue logic. For evaluators of the challenge, it highlights GEMOC Studio’s emphasis on *system-level modeling* where multiple DSMLs can interoperate in a disciplined and analyzable way.

[NOTE]
====

Further Resources:

* BCOoL tutorial page: https://gemoc.org/BCOoL/
* Reference implementation and example: https://github.com/gemoc/bcool-examples

====




== Details of the development status

include::docs/dev_status.adoc[]

image:https://github.com/gemoc/ql-gemoc-lwb2025/actions/workflows/maven.yml/badge.svg[Java CI with Maven, link="https://github.com/gemoc/ql-gemoc-lwb2025/actions/workflows/maven.yml"]
